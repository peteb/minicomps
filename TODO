* Fix coroutines hardcoded to return int
* Interface support for sync queries
* Copy interfaces with lifetime
* Interface support for events
* Support for communication policies
* Minicoros support for sender
* Mutable responses (responses containing ptrs/refs)
* Measure compilation performance
* Apply changes to minicoros
* Should Interfaces be renamed to Components?

* Macros for query declarations using "gmock" style: DECLARE_QUERY(void, MyQuery, (int param1, int param2))
* Try out using the executor lock instead of the component lock, then add "try_execute"
* Build with more errors activated
* Flag for forcing async even if sender and receiver are on the same executor
* any_unaligned_storage should fall back to heap allocated if needed
* Well-defined behavior when components are removed in the middle of a call
* Async queries and events need to copy their arguments/decay
* Protection against weird edge cases; query getting published twice, etc
* Register sync-looking code as async
* Filter handlers for sync queries
* Const parameters, references, etc
* Investigate propagation of cancellations
* Caching

* Load balancing?
* Refactor get_message_id and get_message_info
* TODOs in code
* Call sync queries using async
* Tests that enforce number of allocations
* Should we expose async/sync queries? What should the default be? What about async/sync events?
* Flag to toggle behavior for async queries when receiver has unloaded (cancel request/"black hole", raise error, resend (next frame), DLQ)
* lookup(query1, query2, query3) that works for both sync and async?
* Defer publishing to onLink (automatically)
* Built-in retries?
* Built-in throttling?
* Budgeting for executors

* Hierarchical brokers
* Improve executor performance
* Try out https://github.com/cameron314/readerwriterqueue
